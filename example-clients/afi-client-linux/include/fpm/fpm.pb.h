// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fpm/fpm.proto

#ifndef PROTOBUF_fpm_2ffpm_2eproto__INCLUDED
#define PROTOBUF_fpm_2ffpm_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "qpb/qpb.pb.h"
// @@protoc_insertion_point(includes)

namespace fpm {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_fpm_2ffpm_2eproto();
void protobuf_AssignDesc_fpm_2ffpm_2eproto();
void protobuf_ShutdownFile_fpm_2ffpm_2eproto();

class AddRoute;
class DeleteRoute;
class Message;
class Nexthop;
class RouteKey;

enum Message_Type {
  Message_Type_UNKNOWN_MSG = 0,
  Message_Type_ADD_ROUTE = 1,
  Message_Type_DELETE_ROUTE = 2
};
bool Message_Type_IsValid(int value);
const Message_Type Message_Type_Type_MIN = Message_Type_UNKNOWN_MSG;
const Message_Type Message_Type_Type_MAX = Message_Type_DELETE_ROUTE;
const int Message_Type_Type_ARRAYSIZE = Message_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_Type_descriptor();
inline const ::std::string& Message_Type_Name(Message_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_Type_descriptor(), value);
}
inline bool Message_Type_Parse(
    const ::std::string& name, Message_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_Type>(
    Message_Type_descriptor(), name, value);
}
enum RouteType {
  UNKNOWN = 0,
  NORMAL = 1,
  UNREACHABLE = 2,
  BLACKHOLE = 3
};
bool RouteType_IsValid(int value);
const RouteType RouteType_MIN = UNKNOWN;
const RouteType RouteType_MAX = BLACKHOLE;
const int RouteType_ARRAYSIZE = RouteType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RouteType_descriptor();
inline const ::std::string& RouteType_Name(RouteType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RouteType_descriptor(), value);
}
inline bool RouteType_Parse(
    const ::std::string& name, RouteType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RouteType>(
    RouteType_descriptor(), name, value);
}
// ===================================================================

class Nexthop : public ::google::protobuf::Message {
 public:
  Nexthop();
  virtual ~Nexthop();

  Nexthop(const Nexthop& from);

  inline Nexthop& operator=(const Nexthop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Nexthop& default_instance();

  void Swap(Nexthop* other);

  // implements Message ----------------------------------------------

  inline Nexthop* New() const { return New(NULL); }

  Nexthop* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Nexthop& from);
  void MergeFrom(const Nexthop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Nexthop* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .qpb.IfIdentifier if_id = 2;
  bool has_if_id() const;
  void clear_if_id();
  static const int kIfIdFieldNumber = 2;
  const ::qpb::IfIdentifier& if_id() const;
  ::qpb::IfIdentifier* mutable_if_id();
  ::qpb::IfIdentifier* release_if_id();
  void set_allocated_if_id(::qpb::IfIdentifier* if_id);

  // optional .qpb.L3Address address = 3;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 3;
  const ::qpb::L3Address& address() const;
  ::qpb::L3Address* mutable_address();
  ::qpb::L3Address* release_address();
  void set_allocated_address(::qpb::L3Address* address);

  // @@protoc_insertion_point(class_scope:fpm.Nexthop)
 private:
  inline void set_has_if_id();
  inline void clear_has_if_id();
  inline void set_has_address();
  inline void clear_has_address();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::qpb::IfIdentifier* if_id_;
  ::qpb::L3Address* address_;
  friend void  protobuf_AddDesc_fpm_2ffpm_2eproto();
  friend void protobuf_AssignDesc_fpm_2ffpm_2eproto();
  friend void protobuf_ShutdownFile_fpm_2ffpm_2eproto();

  void InitAsDefaultInstance();
  static Nexthop* default_instance_;
};
// -------------------------------------------------------------------

class RouteKey : public ::google::protobuf::Message {
 public:
  RouteKey();
  virtual ~RouteKey();

  RouteKey(const RouteKey& from);

  inline RouteKey& operator=(const RouteKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RouteKey& default_instance();

  void Swap(RouteKey* other);

  // implements Message ----------------------------------------------

  inline RouteKey* New() const { return New(NULL); }

  RouteKey* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RouteKey& from);
  void MergeFrom(const RouteKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RouteKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .qpb.L3Prefix prefix = 1;
  bool has_prefix() const;
  void clear_prefix();
  static const int kPrefixFieldNumber = 1;
  const ::qpb::L3Prefix& prefix() const;
  ::qpb::L3Prefix* mutable_prefix();
  ::qpb::L3Prefix* release_prefix();
  void set_allocated_prefix(::qpb::L3Prefix* prefix);

  // @@protoc_insertion_point(class_scope:fpm.RouteKey)
 private:
  inline void set_has_prefix();
  inline void clear_has_prefix();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::qpb::L3Prefix* prefix_;
  friend void  protobuf_AddDesc_fpm_2ffpm_2eproto();
  friend void protobuf_AssignDesc_fpm_2ffpm_2eproto();
  friend void protobuf_ShutdownFile_fpm_2ffpm_2eproto();

  void InitAsDefaultInstance();
  static RouteKey* default_instance_;
};
// -------------------------------------------------------------------

class DeleteRoute : public ::google::protobuf::Message {
 public:
  DeleteRoute();
  virtual ~DeleteRoute();

  DeleteRoute(const DeleteRoute& from);

  inline DeleteRoute& operator=(const DeleteRoute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteRoute& default_instance();

  void Swap(DeleteRoute* other);

  // implements Message ----------------------------------------------

  inline DeleteRoute* New() const { return New(NULL); }

  DeleteRoute* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteRoute& from);
  void MergeFrom(const DeleteRoute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeleteRoute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 vrf_id = 1;
  bool has_vrf_id() const;
  void clear_vrf_id();
  static const int kVrfIdFieldNumber = 1;
  ::google::protobuf::uint32 vrf_id() const;
  void set_vrf_id(::google::protobuf::uint32 value);

  // required .qpb.AddressFamily address_family = 2;
  bool has_address_family() const;
  void clear_address_family();
  static const int kAddressFamilyFieldNumber = 2;
  ::qpb::AddressFamily address_family() const;
  void set_address_family(::qpb::AddressFamily value);

  // required .qpb.SubAddressFamily sub_address_family = 3;
  bool has_sub_address_family() const;
  void clear_sub_address_family();
  static const int kSubAddressFamilyFieldNumber = 3;
  ::qpb::SubAddressFamily sub_address_family() const;
  void set_sub_address_family(::qpb::SubAddressFamily value);

  // required .fpm.RouteKey key = 4;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 4;
  const ::fpm::RouteKey& key() const;
  ::fpm::RouteKey* mutable_key();
  ::fpm::RouteKey* release_key();
  void set_allocated_key(::fpm::RouteKey* key);

  // @@protoc_insertion_point(class_scope:fpm.DeleteRoute)
 private:
  inline void set_has_vrf_id();
  inline void clear_has_vrf_id();
  inline void set_has_address_family();
  inline void clear_has_address_family();
  inline void set_has_sub_address_family();
  inline void clear_has_sub_address_family();
  inline void set_has_key();
  inline void clear_has_key();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 vrf_id_;
  int address_family_;
  ::fpm::RouteKey* key_;
  int sub_address_family_;
  friend void  protobuf_AddDesc_fpm_2ffpm_2eproto();
  friend void protobuf_AssignDesc_fpm_2ffpm_2eproto();
  friend void protobuf_ShutdownFile_fpm_2ffpm_2eproto();

  void InitAsDefaultInstance();
  static DeleteRoute* default_instance_;
};
// -------------------------------------------------------------------

class AddRoute : public ::google::protobuf::Message {
 public:
  AddRoute();
  virtual ~AddRoute();

  AddRoute(const AddRoute& from);

  inline AddRoute& operator=(const AddRoute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddRoute& default_instance();

  void Swap(AddRoute* other);

  // implements Message ----------------------------------------------

  inline AddRoute* New() const { return New(NULL); }

  AddRoute* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddRoute& from);
  void MergeFrom(const AddRoute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AddRoute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 vrf_id = 1;
  bool has_vrf_id() const;
  void clear_vrf_id();
  static const int kVrfIdFieldNumber = 1;
  ::google::protobuf::uint32 vrf_id() const;
  void set_vrf_id(::google::protobuf::uint32 value);

  // required .qpb.AddressFamily address_family = 2;
  bool has_address_family() const;
  void clear_address_family();
  static const int kAddressFamilyFieldNumber = 2;
  ::qpb::AddressFamily address_family() const;
  void set_address_family(::qpb::AddressFamily value);

  // required .qpb.SubAddressFamily sub_address_family = 3;
  bool has_sub_address_family() const;
  void clear_sub_address_family();
  static const int kSubAddressFamilyFieldNumber = 3;
  ::qpb::SubAddressFamily sub_address_family() const;
  void set_sub_address_family(::qpb::SubAddressFamily value);

  // required .fpm.RouteKey key = 4;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 4;
  const ::fpm::RouteKey& key() const;
  ::fpm::RouteKey* mutable_key();
  ::fpm::RouteKey* release_key();
  void set_allocated_key(::fpm::RouteKey* key);

  // optional .fpm.RouteType route_type = 5;
  bool has_route_type() const;
  void clear_route_type();
  static const int kRouteTypeFieldNumber = 5;
  ::fpm::RouteType route_type() const;
  void set_route_type(::fpm::RouteType value);

  // required .qpb.Protocol protocol = 6;
  bool has_protocol() const;
  void clear_protocol();
  static const int kProtocolFieldNumber = 6;
  ::qpb::Protocol protocol() const;
  void set_protocol(::qpb::Protocol value);

  // required int32 metric = 8;
  bool has_metric() const;
  void clear_metric();
  static const int kMetricFieldNumber = 8;
  ::google::protobuf::int32 metric() const;
  void set_metric(::google::protobuf::int32 value);

  // repeated .fpm.Nexthop nexthops = 9;
  int nexthops_size() const;
  void clear_nexthops();
  static const int kNexthopsFieldNumber = 9;
  const ::fpm::Nexthop& nexthops(int index) const;
  ::fpm::Nexthop* mutable_nexthops(int index);
  ::fpm::Nexthop* add_nexthops();
  ::google::protobuf::RepeatedPtrField< ::fpm::Nexthop >*
      mutable_nexthops();
  const ::google::protobuf::RepeatedPtrField< ::fpm::Nexthop >&
      nexthops() const;

  // @@protoc_insertion_point(class_scope:fpm.AddRoute)
 private:
  inline void set_has_vrf_id();
  inline void clear_has_vrf_id();
  inline void set_has_address_family();
  inline void clear_has_address_family();
  inline void set_has_sub_address_family();
  inline void clear_has_sub_address_family();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_route_type();
  inline void clear_has_route_type();
  inline void set_has_protocol();
  inline void clear_has_protocol();
  inline void set_has_metric();
  inline void clear_has_metric();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 vrf_id_;
  int address_family_;
  ::fpm::RouteKey* key_;
  int sub_address_family_;
  int route_type_;
  int protocol_;
  ::google::protobuf::int32 metric_;
  ::google::protobuf::RepeatedPtrField< ::fpm::Nexthop > nexthops_;
  friend void  protobuf_AddDesc_fpm_2ffpm_2eproto();
  friend void protobuf_AssignDesc_fpm_2ffpm_2eproto();
  friend void protobuf_ShutdownFile_fpm_2ffpm_2eproto();

  void InitAsDefaultInstance();
  static AddRoute* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  inline Message* New() const { return New(NULL); }

  Message* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Message_Type Type;
  static const Type UNKNOWN_MSG =
    Message_Type_UNKNOWN_MSG;
  static const Type ADD_ROUTE =
    Message_Type_ADD_ROUTE;
  static const Type DELETE_ROUTE =
    Message_Type_DELETE_ROUTE;
  static inline bool Type_IsValid(int value) {
    return Message_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Message_Type_Type_MIN;
  static const Type Type_MAX =
    Message_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Message_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Message_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Message_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Message_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .fpm.Message.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::fpm::Message_Type type() const;
  void set_type(::fpm::Message_Type value);

  // optional .fpm.AddRoute add_route = 2;
  bool has_add_route() const;
  void clear_add_route();
  static const int kAddRouteFieldNumber = 2;
  const ::fpm::AddRoute& add_route() const;
  ::fpm::AddRoute* mutable_add_route();
  ::fpm::AddRoute* release_add_route();
  void set_allocated_add_route(::fpm::AddRoute* add_route);

  // optional .fpm.DeleteRoute delete_route = 3;
  bool has_delete_route() const;
  void clear_delete_route();
  static const int kDeleteRouteFieldNumber = 3;
  const ::fpm::DeleteRoute& delete_route() const;
  ::fpm::DeleteRoute* mutable_delete_route();
  ::fpm::DeleteRoute* release_delete_route();
  void set_allocated_delete_route(::fpm::DeleteRoute* delete_route);

  // @@protoc_insertion_point(class_scope:fpm.Message)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_add_route();
  inline void clear_has_add_route();
  inline void set_has_delete_route();
  inline void clear_has_delete_route();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::fpm::AddRoute* add_route_;
  ::fpm::DeleteRoute* delete_route_;
  int type_;
  friend void  protobuf_AddDesc_fpm_2ffpm_2eproto();
  friend void protobuf_AssignDesc_fpm_2ffpm_2eproto();
  friend void protobuf_ShutdownFile_fpm_2ffpm_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Nexthop

// optional .qpb.IfIdentifier if_id = 2;
inline bool Nexthop::has_if_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Nexthop::set_has_if_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Nexthop::clear_has_if_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Nexthop::clear_if_id() {
  if (if_id_ != NULL) if_id_->::qpb::IfIdentifier::Clear();
  clear_has_if_id();
}
inline const ::qpb::IfIdentifier& Nexthop::if_id() const {
  // @@protoc_insertion_point(field_get:fpm.Nexthop.if_id)
  return if_id_ != NULL ? *if_id_ : *default_instance_->if_id_;
}
inline ::qpb::IfIdentifier* Nexthop::mutable_if_id() {
  set_has_if_id();
  if (if_id_ == NULL) {
    if_id_ = new ::qpb::IfIdentifier;
  }
  // @@protoc_insertion_point(field_mutable:fpm.Nexthop.if_id)
  return if_id_;
}
inline ::qpb::IfIdentifier* Nexthop::release_if_id() {
  // @@protoc_insertion_point(field_release:fpm.Nexthop.if_id)
  clear_has_if_id();
  ::qpb::IfIdentifier* temp = if_id_;
  if_id_ = NULL;
  return temp;
}
inline void Nexthop::set_allocated_if_id(::qpb::IfIdentifier* if_id) {
  delete if_id_;
  if_id_ = if_id;
  if (if_id) {
    set_has_if_id();
  } else {
    clear_has_if_id();
  }
  // @@protoc_insertion_point(field_set_allocated:fpm.Nexthop.if_id)
}

// optional .qpb.L3Address address = 3;
inline bool Nexthop::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Nexthop::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Nexthop::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Nexthop::clear_address() {
  if (address_ != NULL) address_->::qpb::L3Address::Clear();
  clear_has_address();
}
inline const ::qpb::L3Address& Nexthop::address() const {
  // @@protoc_insertion_point(field_get:fpm.Nexthop.address)
  return address_ != NULL ? *address_ : *default_instance_->address_;
}
inline ::qpb::L3Address* Nexthop::mutable_address() {
  set_has_address();
  if (address_ == NULL) {
    address_ = new ::qpb::L3Address;
  }
  // @@protoc_insertion_point(field_mutable:fpm.Nexthop.address)
  return address_;
}
inline ::qpb::L3Address* Nexthop::release_address() {
  // @@protoc_insertion_point(field_release:fpm.Nexthop.address)
  clear_has_address();
  ::qpb::L3Address* temp = address_;
  address_ = NULL;
  return temp;
}
inline void Nexthop::set_allocated_address(::qpb::L3Address* address) {
  delete address_;
  address_ = address;
  if (address) {
    set_has_address();
  } else {
    clear_has_address();
  }
  // @@protoc_insertion_point(field_set_allocated:fpm.Nexthop.address)
}

// -------------------------------------------------------------------

// RouteKey

// optional .qpb.L3Prefix prefix = 1;
inline bool RouteKey::has_prefix() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RouteKey::set_has_prefix() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RouteKey::clear_has_prefix() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RouteKey::clear_prefix() {
  if (prefix_ != NULL) prefix_->::qpb::L3Prefix::Clear();
  clear_has_prefix();
}
inline const ::qpb::L3Prefix& RouteKey::prefix() const {
  // @@protoc_insertion_point(field_get:fpm.RouteKey.prefix)
  return prefix_ != NULL ? *prefix_ : *default_instance_->prefix_;
}
inline ::qpb::L3Prefix* RouteKey::mutable_prefix() {
  set_has_prefix();
  if (prefix_ == NULL) {
    prefix_ = new ::qpb::L3Prefix;
  }
  // @@protoc_insertion_point(field_mutable:fpm.RouteKey.prefix)
  return prefix_;
}
inline ::qpb::L3Prefix* RouteKey::release_prefix() {
  // @@protoc_insertion_point(field_release:fpm.RouteKey.prefix)
  clear_has_prefix();
  ::qpb::L3Prefix* temp = prefix_;
  prefix_ = NULL;
  return temp;
}
inline void RouteKey::set_allocated_prefix(::qpb::L3Prefix* prefix) {
  delete prefix_;
  prefix_ = prefix;
  if (prefix) {
    set_has_prefix();
  } else {
    clear_has_prefix();
  }
  // @@protoc_insertion_point(field_set_allocated:fpm.RouteKey.prefix)
}

// -------------------------------------------------------------------

// DeleteRoute

// required uint32 vrf_id = 1;
inline bool DeleteRoute::has_vrf_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteRoute::set_has_vrf_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteRoute::clear_has_vrf_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteRoute::clear_vrf_id() {
  vrf_id_ = 0u;
  clear_has_vrf_id();
}
inline ::google::protobuf::uint32 DeleteRoute::vrf_id() const {
  // @@protoc_insertion_point(field_get:fpm.DeleteRoute.vrf_id)
  return vrf_id_;
}
inline void DeleteRoute::set_vrf_id(::google::protobuf::uint32 value) {
  set_has_vrf_id();
  vrf_id_ = value;
  // @@protoc_insertion_point(field_set:fpm.DeleteRoute.vrf_id)
}

// required .qpb.AddressFamily address_family = 2;
inline bool DeleteRoute::has_address_family() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteRoute::set_has_address_family() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteRoute::clear_has_address_family() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteRoute::clear_address_family() {
  address_family_ = 0;
  clear_has_address_family();
}
inline ::qpb::AddressFamily DeleteRoute::address_family() const {
  // @@protoc_insertion_point(field_get:fpm.DeleteRoute.address_family)
  return static_cast< ::qpb::AddressFamily >(address_family_);
}
inline void DeleteRoute::set_address_family(::qpb::AddressFamily value) {
  assert(::qpb::AddressFamily_IsValid(value));
  set_has_address_family();
  address_family_ = value;
  // @@protoc_insertion_point(field_set:fpm.DeleteRoute.address_family)
}

// required .qpb.SubAddressFamily sub_address_family = 3;
inline bool DeleteRoute::has_sub_address_family() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeleteRoute::set_has_sub_address_family() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeleteRoute::clear_has_sub_address_family() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeleteRoute::clear_sub_address_family() {
  sub_address_family_ = 0;
  clear_has_sub_address_family();
}
inline ::qpb::SubAddressFamily DeleteRoute::sub_address_family() const {
  // @@protoc_insertion_point(field_get:fpm.DeleteRoute.sub_address_family)
  return static_cast< ::qpb::SubAddressFamily >(sub_address_family_);
}
inline void DeleteRoute::set_sub_address_family(::qpb::SubAddressFamily value) {
  assert(::qpb::SubAddressFamily_IsValid(value));
  set_has_sub_address_family();
  sub_address_family_ = value;
  // @@protoc_insertion_point(field_set:fpm.DeleteRoute.sub_address_family)
}

// required .fpm.RouteKey key = 4;
inline bool DeleteRoute::has_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeleteRoute::set_has_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeleteRoute::clear_has_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeleteRoute::clear_key() {
  if (key_ != NULL) key_->::fpm::RouteKey::Clear();
  clear_has_key();
}
inline const ::fpm::RouteKey& DeleteRoute::key() const {
  // @@protoc_insertion_point(field_get:fpm.DeleteRoute.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::fpm::RouteKey* DeleteRoute::mutable_key() {
  set_has_key();
  if (key_ == NULL) {
    key_ = new ::fpm::RouteKey;
  }
  // @@protoc_insertion_point(field_mutable:fpm.DeleteRoute.key)
  return key_;
}
inline ::fpm::RouteKey* DeleteRoute::release_key() {
  // @@protoc_insertion_point(field_release:fpm.DeleteRoute.key)
  clear_has_key();
  ::fpm::RouteKey* temp = key_;
  key_ = NULL;
  return temp;
}
inline void DeleteRoute::set_allocated_key(::fpm::RouteKey* key) {
  delete key_;
  key_ = key;
  if (key) {
    set_has_key();
  } else {
    clear_has_key();
  }
  // @@protoc_insertion_point(field_set_allocated:fpm.DeleteRoute.key)
}

// -------------------------------------------------------------------

// AddRoute

// required uint32 vrf_id = 1;
inline bool AddRoute::has_vrf_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddRoute::set_has_vrf_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddRoute::clear_has_vrf_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddRoute::clear_vrf_id() {
  vrf_id_ = 0u;
  clear_has_vrf_id();
}
inline ::google::protobuf::uint32 AddRoute::vrf_id() const {
  // @@protoc_insertion_point(field_get:fpm.AddRoute.vrf_id)
  return vrf_id_;
}
inline void AddRoute::set_vrf_id(::google::protobuf::uint32 value) {
  set_has_vrf_id();
  vrf_id_ = value;
  // @@protoc_insertion_point(field_set:fpm.AddRoute.vrf_id)
}

// required .qpb.AddressFamily address_family = 2;
inline bool AddRoute::has_address_family() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddRoute::set_has_address_family() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddRoute::clear_has_address_family() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddRoute::clear_address_family() {
  address_family_ = 0;
  clear_has_address_family();
}
inline ::qpb::AddressFamily AddRoute::address_family() const {
  // @@protoc_insertion_point(field_get:fpm.AddRoute.address_family)
  return static_cast< ::qpb::AddressFamily >(address_family_);
}
inline void AddRoute::set_address_family(::qpb::AddressFamily value) {
  assert(::qpb::AddressFamily_IsValid(value));
  set_has_address_family();
  address_family_ = value;
  // @@protoc_insertion_point(field_set:fpm.AddRoute.address_family)
}

// required .qpb.SubAddressFamily sub_address_family = 3;
inline bool AddRoute::has_sub_address_family() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddRoute::set_has_sub_address_family() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddRoute::clear_has_sub_address_family() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddRoute::clear_sub_address_family() {
  sub_address_family_ = 0;
  clear_has_sub_address_family();
}
inline ::qpb::SubAddressFamily AddRoute::sub_address_family() const {
  // @@protoc_insertion_point(field_get:fpm.AddRoute.sub_address_family)
  return static_cast< ::qpb::SubAddressFamily >(sub_address_family_);
}
inline void AddRoute::set_sub_address_family(::qpb::SubAddressFamily value) {
  assert(::qpb::SubAddressFamily_IsValid(value));
  set_has_sub_address_family();
  sub_address_family_ = value;
  // @@protoc_insertion_point(field_set:fpm.AddRoute.sub_address_family)
}

// required .fpm.RouteKey key = 4;
inline bool AddRoute::has_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AddRoute::set_has_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AddRoute::clear_has_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AddRoute::clear_key() {
  if (key_ != NULL) key_->::fpm::RouteKey::Clear();
  clear_has_key();
}
inline const ::fpm::RouteKey& AddRoute::key() const {
  // @@protoc_insertion_point(field_get:fpm.AddRoute.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::fpm::RouteKey* AddRoute::mutable_key() {
  set_has_key();
  if (key_ == NULL) {
    key_ = new ::fpm::RouteKey;
  }
  // @@protoc_insertion_point(field_mutable:fpm.AddRoute.key)
  return key_;
}
inline ::fpm::RouteKey* AddRoute::release_key() {
  // @@protoc_insertion_point(field_release:fpm.AddRoute.key)
  clear_has_key();
  ::fpm::RouteKey* temp = key_;
  key_ = NULL;
  return temp;
}
inline void AddRoute::set_allocated_key(::fpm::RouteKey* key) {
  delete key_;
  key_ = key;
  if (key) {
    set_has_key();
  } else {
    clear_has_key();
  }
  // @@protoc_insertion_point(field_set_allocated:fpm.AddRoute.key)
}

// optional .fpm.RouteType route_type = 5;
inline bool AddRoute::has_route_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AddRoute::set_has_route_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AddRoute::clear_has_route_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AddRoute::clear_route_type() {
  route_type_ = 0;
  clear_has_route_type();
}
inline ::fpm::RouteType AddRoute::route_type() const {
  // @@protoc_insertion_point(field_get:fpm.AddRoute.route_type)
  return static_cast< ::fpm::RouteType >(route_type_);
}
inline void AddRoute::set_route_type(::fpm::RouteType value) {
  assert(::fpm::RouteType_IsValid(value));
  set_has_route_type();
  route_type_ = value;
  // @@protoc_insertion_point(field_set:fpm.AddRoute.route_type)
}

// required .qpb.Protocol protocol = 6;
inline bool AddRoute::has_protocol() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AddRoute::set_has_protocol() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AddRoute::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AddRoute::clear_protocol() {
  protocol_ = 0;
  clear_has_protocol();
}
inline ::qpb::Protocol AddRoute::protocol() const {
  // @@protoc_insertion_point(field_get:fpm.AddRoute.protocol)
  return static_cast< ::qpb::Protocol >(protocol_);
}
inline void AddRoute::set_protocol(::qpb::Protocol value) {
  assert(::qpb::Protocol_IsValid(value));
  set_has_protocol();
  protocol_ = value;
  // @@protoc_insertion_point(field_set:fpm.AddRoute.protocol)
}

// required int32 metric = 8;
inline bool AddRoute::has_metric() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AddRoute::set_has_metric() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AddRoute::clear_has_metric() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AddRoute::clear_metric() {
  metric_ = 0;
  clear_has_metric();
}
inline ::google::protobuf::int32 AddRoute::metric() const {
  // @@protoc_insertion_point(field_get:fpm.AddRoute.metric)
  return metric_;
}
inline void AddRoute::set_metric(::google::protobuf::int32 value) {
  set_has_metric();
  metric_ = value;
  // @@protoc_insertion_point(field_set:fpm.AddRoute.metric)
}

// repeated .fpm.Nexthop nexthops = 9;
inline int AddRoute::nexthops_size() const {
  return nexthops_.size();
}
inline void AddRoute::clear_nexthops() {
  nexthops_.Clear();
}
inline const ::fpm::Nexthop& AddRoute::nexthops(int index) const {
  // @@protoc_insertion_point(field_get:fpm.AddRoute.nexthops)
  return nexthops_.Get(index);
}
inline ::fpm::Nexthop* AddRoute::mutable_nexthops(int index) {
  // @@protoc_insertion_point(field_mutable:fpm.AddRoute.nexthops)
  return nexthops_.Mutable(index);
}
inline ::fpm::Nexthop* AddRoute::add_nexthops() {
  // @@protoc_insertion_point(field_add:fpm.AddRoute.nexthops)
  return nexthops_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fpm::Nexthop >*
AddRoute::mutable_nexthops() {
  // @@protoc_insertion_point(field_mutable_list:fpm.AddRoute.nexthops)
  return &nexthops_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fpm::Nexthop >&
AddRoute::nexthops() const {
  // @@protoc_insertion_point(field_list:fpm.AddRoute.nexthops)
  return nexthops_;
}

// -------------------------------------------------------------------

// Message

// optional .fpm.Message.Type type = 1;
inline bool Message::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::fpm::Message_Type Message::type() const {
  // @@protoc_insertion_point(field_get:fpm.Message.type)
  return static_cast< ::fpm::Message_Type >(type_);
}
inline void Message::set_type(::fpm::Message_Type value) {
  assert(::fpm::Message_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:fpm.Message.type)
}

// optional .fpm.AddRoute add_route = 2;
inline bool Message::has_add_route() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_add_route() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_add_route() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_add_route() {
  if (add_route_ != NULL) add_route_->::fpm::AddRoute::Clear();
  clear_has_add_route();
}
inline const ::fpm::AddRoute& Message::add_route() const {
  // @@protoc_insertion_point(field_get:fpm.Message.add_route)
  return add_route_ != NULL ? *add_route_ : *default_instance_->add_route_;
}
inline ::fpm::AddRoute* Message::mutable_add_route() {
  set_has_add_route();
  if (add_route_ == NULL) {
    add_route_ = new ::fpm::AddRoute;
  }
  // @@protoc_insertion_point(field_mutable:fpm.Message.add_route)
  return add_route_;
}
inline ::fpm::AddRoute* Message::release_add_route() {
  // @@protoc_insertion_point(field_release:fpm.Message.add_route)
  clear_has_add_route();
  ::fpm::AddRoute* temp = add_route_;
  add_route_ = NULL;
  return temp;
}
inline void Message::set_allocated_add_route(::fpm::AddRoute* add_route) {
  delete add_route_;
  add_route_ = add_route;
  if (add_route) {
    set_has_add_route();
  } else {
    clear_has_add_route();
  }
  // @@protoc_insertion_point(field_set_allocated:fpm.Message.add_route)
}

// optional .fpm.DeleteRoute delete_route = 3;
inline bool Message::has_delete_route() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_delete_route() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_delete_route() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_delete_route() {
  if (delete_route_ != NULL) delete_route_->::fpm::DeleteRoute::Clear();
  clear_has_delete_route();
}
inline const ::fpm::DeleteRoute& Message::delete_route() const {
  // @@protoc_insertion_point(field_get:fpm.Message.delete_route)
  return delete_route_ != NULL ? *delete_route_ : *default_instance_->delete_route_;
}
inline ::fpm::DeleteRoute* Message::mutable_delete_route() {
  set_has_delete_route();
  if (delete_route_ == NULL) {
    delete_route_ = new ::fpm::DeleteRoute;
  }
  // @@protoc_insertion_point(field_mutable:fpm.Message.delete_route)
  return delete_route_;
}
inline ::fpm::DeleteRoute* Message::release_delete_route() {
  // @@protoc_insertion_point(field_release:fpm.Message.delete_route)
  clear_has_delete_route();
  ::fpm::DeleteRoute* temp = delete_route_;
  delete_route_ = NULL;
  return temp;
}
inline void Message::set_allocated_delete_route(::fpm::DeleteRoute* delete_route) {
  delete delete_route_;
  delete_route_ = delete_route;
  if (delete_route) {
    set_has_delete_route();
  } else {
    clear_has_delete_route();
  }
  // @@protoc_insertion_point(field_set_allocated:fpm.Message.delete_route)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace fpm

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::fpm::Message_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fpm::Message_Type>() {
  return ::fpm::Message_Type_descriptor();
}
template <> struct is_proto_enum< ::fpm::RouteType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fpm::RouteType>() {
  return ::fpm::RouteType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_fpm_2ffpm_2eproto__INCLUDED
